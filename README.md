# MIT OCW 6.096 - Introduction to C++
## Assignment 4
Nominally, I would submit this file with the assignment. However, since this is all taken from MIT Open Course Ware, it will just be my version of the solutions posted there (https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-096-introduction-to-c-january-iap-2011/assignments/). I've answered the questions asked in the assignment here. I've constructed the solutions to the various parts of the assignment in the various files. The files `myStack.h` and `myGraph.h` contain the interface for the stack and graph classes we were asked to implement in the assignment. Their implementations can be found in the respective `.cpp` files. The file `mainA4.cpp` contains the tests as well as the other functions (like the min functions and casting stuff).

## 3 Casting
Casting is converting from one type to another. We expect that we can not convert from one type of child to the other, but rather from base to child (downcasting) or child to base (upcasting). Child to parent amounts to simplifying the class where as parent to child amounts to adding to the class (possibly initializing fields with some preset default values). Using the Polygon class as an example, I could have a list of Polygons that could contain both triangles and rectangles and I could find the area of each. However, I would never expect to turn a Triangle into a Rectangle, as suggested in this problem. I might turn a rectangle into a polygon and then into a triangle or vice versa. I would then upcast the rectangle to a polygon and then downcast the polygon to a triangle. In that case, I could either not check the types (static cast) or I could check the types (dynamic cast).

Why use one over the other? Dynamic casts allow for us to use mixed lists without fear of downcasting something incorrectly. It will throw an exception, which we can choose to handle or not. It is slower though. If you don't need to check the types (you have a list of polygons, but you know they are all rectangles), you can then more rapidly cast with static casts.

As far as I can tell, that is what this problem was attempting to emphasize.

## 4 Stack
One thing mentioned in this problem is that template classes cannot readily separate interface and implementation like many other classes. This is due to the compiler creating the object file for the class definition without giving it a specific class. The `T` stays generic in the template class objects and can't be changed later. One way around this is to just put everything in the header file. The method I prefer, outlined here:
https://www.codeproject.com/Articles/48575/How-to-Define-a-Template-Class-in-a-h-File-and-Imp
is to include the source file in the header file. I prefer this method as it still separates interface and implementation. It is a little more picky than it would usually be (you have to write the implementation in a specific file if you can't access the header file). However, it still allows for the same ready exchange of files to create different versions of functionality. If this is considered bad style, it's easy enough to move the contents of the .cpp file into the header file to make an only header file program.